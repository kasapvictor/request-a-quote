import IMask from 'imask';

import {
  $error,
  $prevSuccessValue,
  $status,
  $value,
  changedError,
  changedStatus,
  changedValue,
} from '@entities/input-zip-from';

import { log } from '@shared/lib';
import { isCorrectLength, isOnlyDigits, isValue } from '@shared/lib';
import { Errors, Event, InputElements, Load, Status, Success } from '@shared/types';
import { renderDisabled, renderError, renderLoad, renderSuccess } from '@shared/ui';

import { makeRequest } from './api';
import { initZipMask } from './lib';

const MIN_LENGTH = 5;

export const initInputZipFrom = () => {
  const elements = {
    wrapper: document.getElementById('zip-from'),
    input: document.getElementById('zip-from-input'),
    error: document.getElementById('zip-from-error'),
    success: document.getElementById('zip-from-success'),
    load: document.getElementById('zip-from-load'),
  } as InputElements;

  initZipMask(elements.input);
  events(elements.input);
  watchers(elements);
};

const isValidValue = (value: string): boolean => {
  return [isValue(value), isOnlyDigits(value), isCorrectLength(value, MIN_LENGTH)].every((item) => item);
};

const events = (el: InputElements['input']) => {
  if (!el) {
    return false;
  }

  el.addEventListener(Event.Focus, () => {
    changedStatus(Status.Focused);
    changedError(Errors.Empty);
  });

  el.addEventListener(Event.Input, () => {
    changedStatus(Status.Input);
    changedValue(el.value.trim());
  });

  el.addEventListener(Event.Blur, async () => {
    const value = el.value.trim();
    const isValid = isValidValue(value);

    log({ value, state: $value.getState(), prev: $prevSuccessValue.getState() });

    if (!isValid) {
      changedError(Errors.Required);
      changedStatus(Status.Error);
    }

    if ($prevSuccessValue.getState() === value) {
      changedStatus(Status.Success);
    }

    if (isValid && $prevSuccessValue.getState() !== value) {
      changedStatus(Status.Loading);
      await makeRequest(value);
    }
  });
};

const watchers = (elements: InputElements) => {
  $error.watch((state) => {
    if (elements.error.textContent !== state) {
      renderError(elements.error, state);
    }
  });

  $status.watch((state) => {
    renderDisabled(elements.input, false);
    renderSuccess(elements.success, '');
    renderLoad(elements.load, '');

    if (state === Status.Success) {
      renderSuccess(elements.success, Success.Correct);
    }

    if (state === Status.Loading) {
      renderLoad(elements.load, Load.Request);
      renderDisabled(elements.input, true);
    }
  });
};
